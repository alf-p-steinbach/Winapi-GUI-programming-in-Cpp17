Winapi GUI in C++17 Chapter 4 – Basic GDI graphics.

> ❞ *Quote.*

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Chapter 4. xxx.](#chapter-4-xxx)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## Chapter 4. Basic GDI graphics.

An example of custom graphics is to present a parabola graph in a window, which we’ll do in this chapter:

[image]

Graphics like that is the one thing that you can’t easily do in a text based program, except at extremely or very low resolution. A classic Windows console can only present very crude “[ASCII art](https://en.wikipedia.org/wiki/ASCII_art)” graphics made of characters. At best — but that involves some effort — it can utilize [block graphics characters](https://en.wikipedia.org/wiki/Block_Elements) like `▀` and `▄` to increase vertical resolution and improve the horrendous aspect ratio.

Unix-land terminals and in Windows a Windows Terminal or mintty console view *can* present low res photo like graphics via [Sixel](https://en.wikipedia.org/wiki/Sixel) codes but that’s even more extra effort to do. If we call “made of ordinary characters” level 0, and “block graphics characters” level 1, and “Sixel graphics” level 2, then most novices and professionals alike never get beyond level 0. It can look like this:

<img src="04/images/parabola-as-text.png">

So, learners that start with C++ and want to do graphics generally eschew pure text based standard C++ for 3rd party graphics/GUI libraries or other languages like Python or JavaScript, or tools like spreadsheets. In particular for the special case of graphing a mathematical function a Python program using e.g. Matplotlib or one of the newer Matplotlib-like alternatives, or a spreadhsheet graph of data from a generated CSV file, are easy low effort ways to do it and generally with much higher quality results than one could expect from a DIY C++ program. Or one can simply use a graphing calculator such as Windows’ Calc or online [Desmos](https://www.desmos.com/calculator).

But math functions are not all that graphics is used for. For a novice they are simply natural easy first steps into the world of graphics. And since the Windows GUI API primarily is designed for C and C++, one can do graphics via native Windows functionality such as the original [**GDI** library](https://en.wikipedia.org/wiki/Graphics_Device_Interface), the *graphics device interface*. Additionally Windows offers the GDI successor [**GDI+**](https://en.wikipedia.org/wiki/Graphics_Device_Interface#Windows_XP) introducing (gasp!) *color names*, the GDI+ successor [**Direct2D**](https://en.wikipedia.org/wiki/Direct2D), the [**Direct3D**](https://en.wikipedia.org/wiki/Direct3D) framework for games, and the [**Windows Imaging Component**](https://en.wikipedia.org/wiki/Windows_Imaging_Component) framework for handling pixel based images. And yes, not to forget, Windows also offers an [**OpenGL** implementation](https://learn.microsoft.com/en-us/windows/win32/opengl/opengl); as with the others it’ ready to use functionality with no installation.

We saw in the previous chapter that `RegisterClass`  from the pure windowing functionality in the User library, took a parameter of GDI type, namely a handle to a “brush” used for clearing the background, which we created with the GDI function `CreateSolidBrush`. And generally these two APIs/libraries, User and GDI, are very tightly coupled; to wit, the GDI-specific message `WM_PAINT` is included in the general set and its associated helper functions `BeginPaint` and `EndPaint` are provided by User. So pedagogically it’s necessary to start with the GDI, it’s involved anyway, and in this chapter we’ll only use the GDI.

The problems that we’ll encounter and solve here are mainly general ones that are not GDI specific problems, except the last one:

* The graph is not properly fully redrawn when the window is resized.  
  Solution: *invalidate* the client area when the window is resized (this can be automated).

* For pixel based graphics single computed points on a graph look disconnected.  
  Solution: connect them with lines.

* Text is by default presented using an archaic bitmapped font that’s ugly and lacks certain characters.  
  Solution: check which font `MessageBox` uses for its button, and use that.

* By default the program doesn’t have available the real screen resolution, it looks very low res.  
  Solution: the program needs to declare DPI awareness; real screen resolution is an opt-in feature.

* Even with full screen resolution the graph has visible staircase effect.  
  Solution: use e.g. GDI+ anti-aliasing or, with only GDI, reduce the impression via thicker lines.

So this chapter is to some degree a journey through an obstacle course. But an enlightening journey. Enjoy.


### 4.1. Just plotting the graph.

Our goal for now is to plot the graph of the parabola $y = \frac{1}{4}x^2$ given by

```cpp
auto f( const double x ) -> double { return x*x/4; }
```

… with the the multiples of 5 for $x$ marked specially to make it easy to see the scale. The screenshots at the start showed our final goal. But for now, in this section, the goal is just seeing that graph: no axes, no explanatory text or anything.

We’ll use Windows’ User library, “user32.dll”, for the window creation and message handling, just adding to the chapter 3 code, and we’ll use the GDI library, “gdi32.dll”, for the graphics generation, in User/GDI-speak also known as **painting**.

The easiest for the programmer would be to generate/draw/paint the graphics once “in the window” and be done with it, with the graphics actually stored in an image that the system would use to refresh the screen display as necessary. But the User library is instead designed to (only) let *your* code deal with the screen updates — possibly and usually avoiding the costly per window image storage. To understand this design consider that the User library originated with the birth of Windows circa 1983 to 1985, when a PC’s hardware was very limited both in speed and memory capacity. So it’s designed for **cooperative** as light as possible use of that hardware. And so whenever some part of the client area needs to have its screen presentation updated, e.g. because the window has been resized or (in earlier times) a covering window has been moved, you get a **`WM_PAINT`** message.


### 4.1.1. How to handle `WM_PAINT`.

Handling `WM_PAINT` is usually more than a couple of lines of code, so it’s best delegated to a dedicated function that I systematically name **`on_wm_paint`**, called by the window proc:

[In *04\code\parabola-gdi.v0.cpp*](04/code/parabola-gdi.v0.cpp):

```cpp
    auto CALLBACK window_proc(
        const HWND          window,
        const UINT          msg_id,         // Can be e.g. `WM_COMMAND`, `WM_SIZE`, ...
        const WPARAM        w_param,        // Meaning depends on the `msg_id`.
        const LPARAM        ell_param       // Meaning depends on the `msg_id`.
        ) -> LRESULT
    {
        switch( msg_id ) {
            case WM_DESTROY:    {
                // The window is being destroyed. Terminate the message loop to avoid a hang:
                PostQuitMessage( Process_exit_code::success );
                return 0;
            }
            case WM_PAINT:      { on_wm_paint( window );  return 0; }
        }
        return DefWindowProc( window, msg_id, w_param, ell_param );     // Default handling.
    }
```

This is just a slight elaboration of [the window proc from chapter 3](03.md#332-the-window-procedure).

And to keep the similarity with that earlier version I chose to for now not putting the `WM_DESTROY` handling in its own `on_wm_destroy` function, but that refactoring is of course coming up, because consistency is important.

`on_wm_paint` has to follow a fairly strict protocol of (1) calling **`BeginPaint`**, (2) doing the graphics if `BeginPaint` succeeded, and (3) at least according to the documentation, regardless of success or not calling **`EndPaint`**:

[In *04\code\parabola-gdi.v0.cpp*](04/code/parabola-gdi.v0.cpp):

```cpp
    void on_wm_paint( const HWND window )
    {
        PAINTSTRUCT     info = {};          // Primarily a dc and an update rectangle.

        const HDC dc = BeginPaint( window, &info );
        if( dc ) { paint( window, dc ); }
        EndPaint( window, &info );
    }
```

For now we’ll just ignore the possibility that higher level code may need to know about a `BeginPaint` failure.

A successful `BeginPaint` call produces a handle to a **device context**, which is like a canvas to paint on; the painting result ends up in the window’s client area.

The device context provides automatic pixel level **clipping** of your graphics output. This ensures that no matter what your `paint` code does it won’t affect anything outside the window’s client area. More precisely it won’t affect anything outside the  the area that needs to be regenerated, the **update region** for the current `BeginPaint` call, so except for efficiency considerations you can let your graphics operations do just about anything anywhere with excess (as we’ll do!).

It’s `BeginPaint` that sets the device context’s **clipping region**, the “ignore all pixel setting outside of this” region, namely to the same as the update region, which after `BeginPaint` [is rectangular](https://learn.microsoft.com/en-us/windows/win32/gdi/clipping-regions). `BeginPaint` is also responsible for sending the window a `WM_ERASEBKGND` message if necessary. This scheme is part of the effort to minimize use of memory and processing capacity.

The update region rectangle is available in the `PAINTSTRUCT` and can in principle be used to limit the graphics regeneration. However I’ve never needed that optimization, even with 1990’s PC’s. And so only the `dc` is passed to `paint`.


### 4.1.2. How to plot a parabola with every 5th *x* unit marked.

The console text based way of plotting a graph can be used almost unchanged for pixel based graphics, just that instead of rows of characters one has rows of pixels.

For simple text based plotting the output progresses left to right → on each line, and on a higher level it progresses top to bottom ↓ for the lines. With a reasonable function such as $y = \frac{1}{4}x^2$ one can then ensure, for simplicity, that there is only *one plot point per line* by orienting the math $y$ axis horizontally. This naturally gives a *coordinate system*, sort of chosen by default, no hard thinking necessary or involved, where math $x$ increases downwards, ↓, and math $y$ increases to the right, →.

Code:

[In *04\code\parabola-as-text\level-0.v0-minimal-direct-output.cpp*](04/code/parabola-as-text/level-0.v0-minimal-direct-output.cpp):
```cpp
    void plot()
    {
        const double    horizontal_scaling  = 2;    // A char is ~half as wide as high.
        for( int i_line = -15; i_line <= +15; ++i_line ) {
            const double x = i_line;
            const double y = f( x );

            const int       i_column        = static_cast<int>( y*horizontal_scaling );
            const bool      is_marked       = (i_line % 5 == 0);
            const C_str     plot_char       = (is_marked? "■" : "○");

            if( i_column < 0 or i_column >= 120 ) {
                cout << '\n';
            } else {
                cout << spaces( i_column ) << plot_char << '\n';
            }
        }
    }
```

The `if( i_column < 0 or i_column >= 120 )` is a DIY character level clipping.

Result:

<img src="04/images/parabola-as-text.v0.png">

With GDI graphics one can assume that, unlike a character cell, a pixel is square. I.e. an ***aspect ratio of 1***. So there is no `horizontal_scaling`, but since pixels are small the math view coordinates need to be scaled up in order to see a reasonable size graph, e.g. a `scaling` of 10 or so (this maps math $x = -15$ to pixel offset `-150` from the graph’s middle):

[In *04\code\parabola-gdi.v0\with.single-loop.using-precomputed-bound.cpp*](04/code/parabola-gdi.v0/with.single-loop.using-precomputed-bound.cpp):

```cpp
    void paint( const HWND window, const HDC dc )
    {
        static constexpr COLORREF black = RGB( 0, 0, 0 );
        static const auto black_brush = static_cast<HBRUSH>( GetStockObject( BLACK_BRUSH ) );

        const RECT  r   = winapi::client_rect_of( window );
        const Nat   h   = r.bottom - r.top;     // r.top is always 0 for a client rect, but.

        const Nat   i_mid_pixel_row = h/2;

        const double scaling = 10;              // So e.g. math x = -15 maps to pixel row -150.

        // Plot the parabola.
        for( Nat i_pixel_row = 0; i_pixel_row < h; ++i_pixel_row ) {
            const int       relative_row_index = i_pixel_row - i_mid_pixel_row;
            const double    x                   = 1.0*relative_row_index/scaling;
            const double    y                   = f( x );
            const int       i_pixel_col         = int( scaling*y );

            SetPixel( dc, i_pixel_col, i_pixel_row, black );    // x hor y ver pixel coordinate.
        }

        // Add markers for every 5 math units of math x axis.
        const Nat       max_int_x_magnitude     = Nat( i_mid_pixel_row/scaling );
        const double    max_marker_x_magnitude  = 5*(max_int_x_magnitude/5);    // Symmetrical.
        for( double x = -max_marker_x_magnitude; x <= max_marker_x_magnitude; x += 5 ) {
            const double    y               = f( x );
            const int       i_pixel_row     = i_mid_pixel_row + int( scaling*x );
            const int       i_pixel_col     = int( scaling*y );

            const auto square_marker_rect = RECT{
                i_pixel_col - 2, i_pixel_row - 2, i_pixel_col + 3, i_pixel_row + 3
                };
            FillRect( dc, &square_marker_rect, black_brush );
        }
    }
```

The color value `black` — it’s just a 32-bit value, not a dynamic object — is used in the `SetPixel` call for the graph plotting, and the brush object `black_brush` is used in the `FillRect` call to set a square marker on the graph. Ordinarily **GDI objects** like brushes are dynamically created via calls such as `CreateSolidBrush` that we used in chapter 3, and unless ownership is transferred the object should better also be **destroyed** via a call to GDI’s **`DeleteObject`**. However a **stock object**, obtained from `GetStockObject`, is provided by the system and neither needs to be nor should be destroyed; it lives forever.

The [`SetPixel` function declaration](https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpixel) calls the two position values `x` and `y`. Our code’s corresponding arguments are `i_pixel_col` and `i_pixel_row`. So with GDI by default the ***x* axis** is left to right horizontal, →, and the ***y* axis** is top to bottom vertical, ↓.

This view of the coordinates is necessary to understand e.g. the field names in a `RECT`.

The **`RECT`** used for the square marker holds 4 values, `top`, `left`, `bottom` and `right`, where the latter two are the coordinates of the pixel *beyond* the rectangle, diagonally down right from the down right corner. I.e. *width* = `right` - `left` and *height* = `bottom` - `top`. The API provides some [`RECT` support functions](https://learn.microsoft.com/en-us/windows/win32/gdi/rectangle-functions) but curiously not width and height functions…

For completeness, `winapi::client_rect_of` is defined by this program’s code as

[In *04\code\parabola-gdi.v0\with.single-loop.using-precomputed-bound.cpp*](04/code/parabola-gdi.v0/with.single-loop.using-precomputed-bound.cpp):

```cpp
namespace winapi {
    auto client_rect_of( const HWND window )
        -> RECT
    {
        RECT r;
        GetClientRect( window, &r );
        return r;
    }
}  // winapi
```

Result:

<img src="04/images/parabola.v0.png">


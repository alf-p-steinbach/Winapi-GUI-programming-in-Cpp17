Winapi GUI in C++17 Chapter 4 – Basic GDI graphics.

> ❞ *Quote.*

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Chapter 4. xxx.](#chapter-4-xxx)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## Chapter 4. xxx.

An example of custom graphics is to present a parabola graph in a window, which we’ll do in this chapter:

[image]

Graphics is the one thing that you can’t easily do in a text based program, except at extremely or very low resolution. A classic Windows console can only present very crude “[ASCII art](https://en.wikipedia.org/wiki/ASCII_art)” graphics made of characters, at best — but that involves some effort — utilizing [block graphics characters](https://en.wikipedia.org/wiki/Block_Elements) like `▀` and `▄` to increase vertical resolution and improve the horrendous aspect ratio. Unix-land terminals and in Windows a Windows Terminal or mintty console view *can* present low res photo like graphics via [Sixel](https://en.wikipedia.org/wiki/Sixel) codes but that’s even more extra effort to do. If we call “made of ordinary characters” level 0, and “block graphics characters” level 1, and “Sixel graphics” level 2, then most novices and professionals alike never get beyond level 0. It can look like this:

<img src="04/images/parabola-as-text.png">

So, learners that start with C++ and want to do graphics generally eschew pure text based standard C++ for 3rd party graphics/GUI libraries or other languages like Python or JavaScript, or tools like spreadsheets. In particular for the special case of graphing a mathematical function a Python program using e.g. Matplotlib or one of the newer Matplotlib-like alternatives, or a spreadhsheet graph of data from a generated CSV file, are easy low effort ways to do it and generally with much higher quality results than one could expect from a DIY C++ program. Or one can simply use a graphing calculator such as Windows’ Calc or online [Desmos](https://www.desmos.com/calculator).

But math functions are not all that graphics is used for. For a novice they are simply natural easy first steps into the world of graphics. And since — unlike e.g. the Mac’s GUI API — the Windows GUI API primarily is designed for C and C++, one can do graphics via native Windows functionality such as the original [**GDI** library](https://en.wikipedia.org/wiki/Graphics_Device_Interface), the *graphics device interface*. Additionally Windows offers the GDI successor [**GDI+**](https://en.wikipedia.org/wiki/Graphics_Device_Interface#Windows_XP) introducing (gasp!) *color names*, the GDI+ successor [**Direct2D**](https://en.wikipedia.org/wiki/Direct2D), the [**Direct3D**](https://en.wikipedia.org/wiki/Direct3D) framework for games, and the [**Windows Imaging Component**](https://en.wikipedia.org/wiki/Windows_Imaging_Component) framework for handling pixel based images. And yes, not to forget, Windows also offers an [**OpenGL** implementation](https://learn.microsoft.com/en-us/windows/win32/opengl/opengl); as with the others it’ ready to use functionality with no installation.

We saw in the previous chapter that `RegisterClass`  from the pure windowing functionality in the User library, took a parameter of GDI type, namely a handle to a “brush” used for clearing the background, which we created with the GDI function `CreateSolidBrush`. And generally these two APIs/libraries, User and GDI, are very tightly coupled with the GDI-specific message `WM_PAINT` included in the general set and its associated helper functions `BeginPaint` and `EndPaint` provided by User. So pedagogically it’s necessary to start with the GDI, it’s involved anyway, and in this chapter we’ll only use the GDI.




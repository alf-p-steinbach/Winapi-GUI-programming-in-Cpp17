Winapi GUI in C++17 Chapter 3 – General window creation & message handling.

> ❞ *quote.*

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Chapter 3. xxx.](#chapter-3-xxx)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Chapter 3. General window creation & message handling.

Our first **general window** will look like this:

$\quad$ <img src="03/images/empty-basic-window.v0.png">

### 3.1. Window parts.

The orange area is made orange by our C++ code. I.e. it’s not the Windows default. This area is called the **client area** because it’s the area where your code, the Windows API’s client code, presents stuff.

Above the client area is the window **title bar** with some control elements — when you click the **window icon** at the left you get a system menu (it can also be invoked via the **`Alt`+`space`** shortcut), and the `–`, `□` and `×` to the right are respectively minimize, maximize and close **buttons**.

Around the client area and title bar is a **window frame**. In modern Windows it’s unfortunately difficult to see that this is a **thick frame** that can be used to resize the window. Conversely, a window with a **thin frame** (it looks just about the same in modern Windows) can’t be resized by the user. To show the resizability in the screenshot I placed the mouse cursor over the thick frame, whence it changes shape to `⇔` resizing. In the code the frame thickness and hence resizability is a “window style” flag passed to `CreateWindow`, where this code uses `WS_OVERLAPPEDWINDOW` which includes `WS_THICKFRAME`.

Here’s a screenshot showing the **system menu** in action:

$\quad$ <img src="03/images/empty-basic-window.v0.system-menu.png">

As that menu informs you you can use keyboard shortcut **`Alt`+`F4`** to close the window. This was originally, in the 1980’s, part of the [IBM *Common User Access*](https://en.wikipedia.org/wiki/IBM_Common_User_Access#Influence) standard for keyboard shortcuts. When you click the desktop background and press `Alt`+`F4` you’re closing the desktop window which then gives you the Windows shutdown dialog.

Alternatively you can double-click the window icon to close the window. But some windows like the modern Windows Calc window don’t use that default functionality — the common conventions are just that, conventions, not absolute law. With Calc the apparent window icon is just a graphic presented by Calc and double-clicking that graphic unreasonably maximises the calculator instead of closing the window, but even in Calc you can still access the system menu via `Alt`+`space`.


### 3.2. Window creation.

#### 3.2.1. Creating the Windows API “window class”.

Some of the visible aspects of this window are specified by its **window class**, which is a kind of template for window instances. We need to use that general mechanism even though this program only creates one window. There’s no predefined window class for a general main window so our code has to create one, and the parameters used for that creation are

[In *03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
const auto& window_class_name = L"A basic empty main window";

auto make_window_class_params()
    -> WNDCLASSW
{
    WNDCLASSW params = {};
    params.lpfnWndProc      = &window_proc;
    params.hInstance        = GetModuleHandleW( 0 );        // Not very useful in modern code.
    params.hIcon            = LoadIcon( 0, IDI_APPLICATION );   // ANSI or Wide, either is OK.
    params.hCursor          = LoadCursor( 0, IDC_ARROW );       // ANSI or Wide, either is OK.
    params.hbrBackground    = CreateSolidBrush( RGB( 0xFF, 0x80, 0x00 ) );          // Orange.
    params.lpszClassName    = window_class_name;
    return params;
};
```

The first parameter, the **window proc**, is a single callback function that handles events for the window. It defines the window’s looks and functionality by how it handles the events. In this program it uses default handling of all events except that it needs to terminate the program when the window is closed, which it does via its handling of the `WM_DESTROY` event.

The `LoadIcon` and `LoadCursor` calls use \<windows.h\> **name macros**. By default these names are mapped to respectively `LoadIconA` and `LoadCursorA`, which work fine with the default definitions of `IDI_APPLICATION` and `IDC_ARROW`. But if the symbol **`UNICODE`** is defined when \<windows.h\> is included then the name macros map to respectively `LoadIconW` and `LoadCursorW`, which work fine with the `UNICODE`-dependent definitions of `IDI_APPLICATION` and `IDC_ARROW`.

Since the result for these two functions is the same regardless of ANSI or wide function I just wrote it this way, using the macros. Otherwise the code would have had to require or ensure that `UNICODE` is defined, unlike our code examples so far. But we’ll do that in version 1 because as you’ll see that can avoid some nasty bugs.

To create the window class the program passes these parameters to **`RegisterClass`**, which returns a 16-bit `ATOM` id for the new window class object. However to use that id with e.g. `CreateWindow` it needs to be reinterpreted as a pointer, so that’s both risky and cumbersome. And so instead it’s common to use the window class name, here “A basic empty main window”.

And you can see that name e.g. via Microsoft’s Spy++, command `spyxx` in an environment with the Microsoft tools available, e.g. after [running `vcvars64`](02.md#231-the-vcvars-batch-files):

<img src="03/images/spyxx.windowclass-name.annotated.png">

The window class creation:

[In *03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
enum Process_exit_code: int { success = 0, failure = EXIT_FAILURE };

auto run()
    -> Process_exit_code
{
    const WNDCLASSW window_class_params = make_window_class_params();
    RegisterClassW( &window_class_params );
    ⋮
```

This does not check whether the `RegisterClass` call succeeded because if it failed then `CreateWindow` will fail, and that’s checked.

#### 3.2.2. Creating the window object.

The result of **`CreateWindow`** is a **handle** value that represents the new object.

In C and C++ a handle is typewise a pointer. By default some such as `HBRUSH` and **`HWND`** are distinct `struct` pointer types, and some such as `HGDIOBJ` are just `void*`. These types provide *some* safety for natural code, and they generally permit naturally meaningful implicit conversions, but it’s a very imperfect system so one still one needs to be careful!

Usually handle value `0` (a nullpointer) denotes error, but [there are some exceptions](https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443). For example, `CreateFile` instead reports error by returning **`INVALID_HANDLE_VALUE`** which is `-1` cast to `HANDLE`. But most functions including `CreateWindow` just use the nullvalue as error indication:

[In *03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
    const HWND window = CreateWindowW(
        window_class_name,
        L"My first general Windows API window!",
        WS_OVERLAPPEDWINDOW,                        // Resizable and has a title bar.
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 280,     // x y w h
        HWND(),                                     // Owner window; none.
        HMENU(),                                    // Menu handle or child window id.
        GetModuleHandleW( 0 ),                      // Not very useful in modern code.
        nullptr                                     // Custom parameter for app’s use.
        );
    if( not window ) {
        return Process_exit_code::failure;          // Avoid hanging in the event loop.
    }
```

The prefix `WS_` for the “style” flags is short for **window style**.

You can inspect or change the window style flags later. For example, most generally they can be changed via a call to `SetWindowLongPtr` with index `GWL_STYLE`. But the style `WS_VISIBLE` should better be inspected via the dedicated function `IsWindowVisible` or changed via the dedicated function `ShowWindow` used below.

The `CW_USEDEFAULT` values for the window position cause the window to be placed automatically. By default Windows places windows in a diagonal down the screen and starts a new diagonal when it runs out of room. You can technically also use `CW_USEDEFAULT` for the width and height.

If window creation fails then a loop until the window closes would just hang, and so, considering the possibility of typos or resource depletion or whatever, this code checks if the window creation succeeded, and if not then it bails out.


#### 3.2.3. Displaying the window.

A top level window is by default created **hidden**, meaning that it has no on-screen presentation. In this state you can populate the window with the contents that you want, without the user seeing that process. Then when all is ready you can call **ShowWindow** to make the window **visible**:

[In *03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
    ShowWindow( window, SW_SHOWDEFAULT );           // Displays the window.
```

The `SW_SHOWDEFAULT` says to present the window as minimized, normal or maximized according to the parent process’ wishes.

However, for the first call to `ShowWindow` the `SHOW_`… specification is *ignored*. In the first call you get `SW_SHOWDEFAULT` no matter what you specify. And this is intentional [documented behavior](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow#remarks) except that that documentation also includes some nonsense.



### 3.3. Window events, a.k.a. messages.

After creation the window’s life consists of handling events, in a very low level C style way.

The terminology here reflects the history of Windows’ creation. In the late 1970’s the Xerox corporation did a lot of groundbreaking research at their research center in Palo Alto, California, the Xerox PARC center. They invented local area networks, workstations with bitmapped displays, and not the least, in the **Smalltalk** project, object oriented techniques and user interfaces based on windows and mousing — at the time called [WIMP](https://en.wikipedia.org/wiki/Wimp): window, icon, menu, pointer.

Smalltalk is a dynamic object oriented language where method calls are called **messages**. This probably trickled down to Microsoft via Apple’s participation in a Xerox technology transfer program (look up the [Apple Lisa](https://en.wikipedia.org/wiki/Apple_Lisa)). And so the window events in Windows are called “messages”, though they’re represented in C level type unsafe style with just an integer message identifier value such as `WM_SIZE` accompanied by two general integer values with message-dependent meanings.

The `WM_` prefix is short for *window message*. There are a lot of them but for this program we’ll only be checking for `WM_DESTROY` which is a notification that the window’s being destroyed, and `WM_QUIT` which requests that the application terminates. `WM_DESTROY` is a message to a window while `WM_QUIT`, in spite of the `WM_` prefix , is a message to the thread.

The main code’s responsibility after creating a window is to fetch messages from the thread’s **message queue**, and dispatch each to the relevant window’s handler. That handler is called a **window proc**. Which terminology again probably comes from Apple: after Smalltalk they used Pascal for their early work, and in Pascal a `void` function is called a “procedure”.

The message fetching and dispatching is called a **message loop**, here

[In *03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
    // Event loop a.k.a. message loop:
    MSG msg;
    while( GetMessageW( &msg, 0, 0, 0 ) ) {         // We’re ignoring that it can fail.
        TranslateMessage( &msg );           // Provides e.g. Alt+Space sysmenu shortcut.
        DispatchMessageW( &msg );           // Calls the window proc of relevant window.
    }
    assert( msg.message == WM_QUIT );
    return Process_exit_code( msg.wParam );
}
```

`GetMessage` returns 0 when it retrieves a `WM_QUIT` message, and otherwise non-zero. For successful calls the non-zero return value is positive, for errors it’s negative. But an error for `GetMessage` is an extremely rare occurrence so, while we’re going to address that in version 1 that possibility is commonly just ignored to get simpler code like this.

The `TranslateMessage` call is not strictly necessary but it provides e.g. the `Alt`+`space` shortcut for the system menu, by identifying certain keypress combinations and adding messages to the queue, called **posting** messages.

Some messages instead bypass the queue and the above loop; more or less direct invocations of a window proc. This is called **sending** a message. Windows provides `PostMessage` and `SendMessage` to do this yourself when you might need it.

`DispatchMessage` does more than just identifying the receiver window and calling the window proc. It also supports hooks for inspecting the message stream, as used by e.g. Spy++, although that might be accomplished by an internal call of `SendMessage`. Plus that it has special handling of `WM_TIMER` messages.

The `MSG` structure includes a time stamp for the message, and in the Smalltalk project such time stamps were identified as crucial e.g. to be able to handle double-clicking (they also identified undecoded keyboards and bit blitting as crucial fundamentals). However in Windows the time stamp is not passed on to the handler, the window proc. Instead the window proc, if it needs it, may use `GetMessageTime` to get the time stamp of the message last fetched from the queue.

Anyway, that’s the — somewhat circular — reason why the window proc doesn’t have a time stamp parameter:

[In *03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
auto CALLBACK window_proc(
    const HWND          window,
    const UINT          msg_id,         // Can be e.g. `WM_COMMAND`, `WM_SIZE`, ...
    const WPARAM        w_param,        // Meaning depends on the `msg_id`.
    const LPARAM        ell_param       // Meaning depends on the `msg_id`.
    ) -> LRESULT
{
    if( msg_id == WM_DESTROY ) {
        // The window is being destroyed. Terminate the message loop to avoid a hang:
        PostQuitMessage( Process_exit_code::success );
        return 0;
    }
    return DefWindowProcW( window, msg_id, w_param, ell_param );    // Default handling.
}
```

The names `w_param` and `ell_param`, or in Microsoft-speak `wParam` and `lParam`, are short for *word parameter* and *long parameter*, reflecting original 16 and 32 bit sizes.

In modern 64-bit Windows both are 64-bit unsigned integers, but still only `ell_param` is used to represent actual pointers.

**`DefWindowProc`** provides general default handling of a message. A different design is used for “dialog windows” where the higher level event handler returns 0 to request default handling. Regardless of mechanism, usually one *either* fully handles a message, *or* requests default handling, but not both.


### 3.4. The complete program, version 0.

Except for a trivial `main` the above discussed code is all, and here’s the single file:

[*03\code\empty-basic-window.v0.cpp*](03/code/empty-basic-window.v0.cpp):

```cpp
#include <windows.h>

#include <cassert>          // assert
#include <cstdlib>          // EXIT_FAILURE

enum Process_exit_code: int { success = 0, failure = EXIT_FAILURE };

auto CALLBACK window_proc(
    const HWND          window,
    const UINT          msg_id,         // Can be e.g. `WM_COMMAND`, `WM_SIZE`, ...
    const WPARAM        w_param,        // Meaning depends on the `msg_id`.
    const LPARAM        ell_param       // Meaning depends on the `msg_id`.
    ) -> LRESULT
{
    if( msg_id == WM_DESTROY ) {
        // The window is being destroyed. Terminate the message loop to avoid a hang:
        PostQuitMessage( Process_exit_code::success );
        return 0;
    }
    return DefWindowProcW( window, msg_id, w_param, ell_param );    // Default handling.
}

const auto& window_class_name = L"A basic empty main window";

auto make_window_class_params()
    -> WNDCLASSW
{
    WNDCLASSW params = {};
    params.lpfnWndProc      = &window_proc;
    params.hInstance        = GetModuleHandleW( 0 );        // Not very useful in modern code.
    params.hIcon            = LoadIcon( 0, IDI_APPLICATION );   // ANSI or Wide, either is OK.
    params.hCursor          = LoadCursor( 0, IDC_ARROW );       // ANSI or Wide, either is OK.
    params.hbrBackground    = CreateSolidBrush( RGB( 0xFF, 0x80, 0x00 ) );          // Orange.
    params.lpszClassName    = window_class_name;
    return params;
};

auto run()
    -> Process_exit_code
{
    const WNDCLASSW window_class_params = make_window_class_params();
    RegisterClassW( &window_class_params );

    const HWND window = CreateWindowW(
        window_class_name,
        L"My first general Windows API window!",
        WS_OVERLAPPEDWINDOW,                        // Resizable and has a title bar.
        CW_USEDEFAULT, CW_USEDEFAULT, 400, 280,     // x y w h
        HWND(),                                     // Owner window; none.
        HMENU(),                                    // Menu handle or child window id.
        GetModuleHandleW( 0 ),                      // Not very useful in modern code.
        nullptr                                     // Custom parameter for app’s use.
        );
    if( not window ) {
        return Process_exit_code::failure;          // Avoid hanging in the event loop.
    }

    ShowWindow( window, SW_SHOWDEFAULT );           // Displays the window.

    // Event loop a.k.a. message loop:
    MSG msg;
    while( GetMessageW( &msg, 0, 0, 0 ) ) {         // We’re ignoring that it can fail.
        TranslateMessage( &msg );           // Provides e.g. Alt+Space sysmenu shortcut.
        DispatchMessageW( &msg );           // Calls the window proc of relevant window.
    }
    assert( msg.message == WM_QUIT );
    return Process_exit_code( msg.wParam );
}

auto main() -> int { return run(); }
```


asd

---
### asdasd








asdasd
